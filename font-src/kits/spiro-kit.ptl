import 'spiro' as SpiroJs
import '../support/curve-util' as CurveUtil
import '../support/transform' as Transform
import [SpiroExpansionContext1 SpiroExpansionContext2] from '../support/spiro-expand'
import [fallback mix bez2 bez3] from '../support/utils'
import [SpiroGeometry CombineGeometry] from "../support/geometry"

export : define [SetupBuilders args] : begin
	define [object para Glyph Contrast GlobalTransform Stroke] args

	define [g4 x y f] {.x x .y y .type 'g4' .af f}
	define [g2 x y f] {.x x .y y .type 'g2' .af f}
	define [corner x y f] {.x x .y y .type 'corner' .af f}
	define [flat x y f] {.x x .y y .type 'left' .af f}
	define [curl x y f] {.x x .y y .type 'right' .af f}
	define [close f] {.type 'close' .af f}
	define [end f] {.type 'end' .af f}

	define straight {.l flat .r curl}

	#directional bi-knots
	let
		directions : list
			* {.name 'up'    .x 0    .y 1}
			* {.name 'down'  .x 0    .y (-1)}
			* {.name 'left'  .x (-1) .y 0}
			* {.name 'right' .x 1    .y 0}
		adhensions : list
			* {.name 'start' .l 0        .r 0.01}
			* {.name 'mid'   .l (-0.005) .r 0.005}
			* {.name 'end'   .l (-0.01)  .r 0}
		knotTypes : list
			* {g4 g4 g4}
			* {g2 g2 g2}
			* {corner corner corner}
			* {straight flat curl}
		foreach [_kt : items-of knotTypes] : let [{ sink kl kr } _kt] : begin
			foreach [_d : items-of directions] : let [d _d] : begin
				set sink.(d.name) {.}
				foreach [adh : items-of adhensions] : let [a adh] : begin
					set sink.(d.name).(a.name) : lambda [x y af] : list
						kl (x + d.x * a.l) (y + d.y * a.l) af
						kr (x + d.x * a.r) (y + d.y * a.r) af

	# Aux functions
	define [widths l r] : lambda [] : if this.setWidth : this.setWidth l r
	define [widths.lhs w] : widths [fallback w Stroke] 0
	define [widths.rhs w] : widths 0 [fallback w Stroke]
	define [widths.center w] : widths ([fallback w Stroke] / 2) ([fallback w Stroke] / 2)

	# Gizmo handler
	define [disable-contrast] : lambda [] : set this.contrast 1

	define [heading d] : lambda [] : if (this.headsTo) : this.headsTo d
	define [widths.heading l r d] : lambda [] : begin
		if this.setWidth : this.setWidth l r
		if this.headsTo : this.headsTo d
	define [widths.lhs.heading w d] : lambda [] : begin
		if this.setWidth : this.setWidth [fallback w Stroke] 0
		if this.headsTo : this.headsTo d
	define [widths.rhs.heading w d] : lambda [] : begin
		if this.setWidth : this.setWidth 0 [fallback w Stroke]
		if this.headsTo : this.headsTo d
	define [widths.center.heading w d] : lambda [] : begin
		if this.setWidth : this.setWidth ([fallback w Stroke] / 2) ([fallback w Stroke] / 2)
		if this.headsTo : this.headsTo d
	define [unimportant] : if this.setUnimportant : this.setUnimportant
	define [important] nothing

	# Interpolation pesudoknots
	define [afInterpolate before after args] : g4
		mix before.x after.x args.rx
		mix before.y after.y args.ry
		fallback args.raf unimportant
	define [afInterpolateG2 before after args] : g2
		mix before.x after.x args.rx
		mix before.y after.y args.ry
		fallback args.raf unimportant
	define [afInterpolateThem before after args] : begin
		local innerKnots {}
		foreach {rx ry rt} [items-of args.rs] : innerKnots.push : [fallback args.ty g2]
			mix before.x after.x rx
			mix before.y after.y ry
			piecewise
				(args.raf && args.raf.blend && (rt != nothing)) [args.raf.blend rt]
				args.raf                                        args.raf
				true                                            unimportant
		return innerKnots
	define [afInterpolateSNeck before after args] : list
		g2
			mix before.x after.x (1 / 2 - args.px / 6)
			mix before.y after.y (1 / 2 - args.py / 6)
			widths (args.sw * args.ps) (args.sw * (1 - args.ps))
		g2
			mix before.x after.x (1 / 2 + args.px / 6)
			mix before.y after.y (1 / 2 + args.py / 6)
			widths (args.sw * (1 - args.ps)) (args.sw * args.ps)

	define [alsoThru rx ry raf] {.type 'interpolate' .rx rx .ry ry .raf raf .af afInterpolate}
	set alsoThru.g2 : lambda [rx ry raf] {.type 'interpolate' .rx rx .ry ry .raf raf .af afInterpolateG2}
	set alsoThru.sNeck : lambda [px py sw ps] {.type 'interpolate' .px px .py py .sw sw .ps ps .af afInterpolateSNeck}
	define [alsoThruThem rs raf ty] {.type 'interpolate' .rs rs .raf raf .ty ty .af afInterpolateThem}
	define [bezControlsImpl x1 y1 x2 y2 samples raf ty] : begin
		local rs {}
		foreach j [range 1 samples] : rs.push : list
			bez3 0 x1 x2 1 (j / samples)
			bez3 0 y1 y2 1 (j / samples)
			j / samples
		alsoThruThem rs raf
	define [bezcontrols x1 y1 x2 y2 _samples raf]
		bezControlsImpl x1 y1 x2 y2 [fallback _samples 3] raf
	define [quadcontrols x1 y1 _samples raf]
		bezControlsImpl (x1 * 2 / 3) (y1 * 2 / 3) [mix 1 x1 (2 / 3)] [mix 1 y1 (2 / 3)] [fallback _samples 3] raf

	define DEFAULT_STEPS 6
	define {jhv, jvh} : let [cache {}] : begin
		local [build samples _superness] : begin
			local superness : fallback _superness args.superness
			local hv {}
			local vh {}
			foreach [j : range 1 samples] : begin
				local theta : (j + 1) / (samples + 2) * Math.PI / 2
				local c : Math.pow [Math.cos theta] (2 / superness)
				local s : Math.pow [Math.sin theta] (2 / superness)
				hv.push { s (1 - c) }
				vh.push { (1 - c) s }
			return {.hv hv .vh vh}
		local [hv samples _superness] : begin
			if (_superness) : return [build samples _superness].hv
			if (!cache.(samples)) : set cache.(samples) : build samples _superness
			return cache.(samples).hv
		local [vh samples _superness] : begin
			if (_superness) : return [build samples _superness].vh
			if (!cache.(samples)) : set cache.(samples) : build samples _superness
			return cache.(samples).vh
		list hv vh
	define [archv samples superness] : alsoThruThem [jhv [fallback samples DEFAULT_STEPS] superness]
	set archv.superness : lambda [s] : archv DEFAULT_STEPS s
	define [arcvh samples superness] : alsoThruThem [jvh [fallback samples DEFAULT_STEPS] superness]
	set arcvh.superness : lambda [s] : arcvh DEFAULT_STEPS s

	define [complexThru] : begin
		local a : {}.slice.call arguments
		return {.type 'interpolate' .af [lambda [before after args] : begin \\
			local ks {}
			foreach knot [items-of a] : ks.push [knot.af.call this before after knot]
			return ks
		]}


	define [flattenImpl sink knots] : begin
		foreach p [items-of knots] : piecewise
			(p <@ Array) : flattenImpl sink p
			true         : sink.push p
	define [nCyclic p n] : (p + n + n) % n
	define [flatten s knots0] : begin
		local knots : list
		flattenImpl knots knots0

		# Unwrap interpolation knots
		local unwrapped false
		foreach j [range 0 knots.length] : if (knots.(j) && knots.(j).type === 'interpolate') : begin
			local kBefore  knots.[nCyclic (j - 1) knots.length]
			local kAfter   knots.[nCyclic (j + 1) knots.length]
			set knots.(j) : knots.(j).af.call s kBefore kAfter knots.(j)
			set unwrapped true

		if unwrapped : return : flatten s knots
		return knots

	define [dropTailKnot knots] : begin
		define last knots.(knots.length - 1)
		if (last && (last.type === 'close' || last.type === 'end')) : begin
			set knots.length : knots.length - 1
			return : last.type === 'close'

	define [prepareSpiroKnots _knots s] : begin
		local knots _knots
		while (knots.0 && knots.0 <@ Function) : begin [knots.0.call s] [knots.splice 0 1]
		define closed : dropTailKnot knots
		set knots : flatten s knots
		return { .knots knots .closed closed }

	define [iterateNormals s closed] : begin
		local knotsP2 : s.getPass2Knots closed [fallback s.contrast Contrast]
		local s2 : new SpiroExpansionContext2 s.controlKnots s.gizmo
		SpiroJs.spiroToArcsOnContext knotsP2 closed s2

	define [dispiro] : let [args : {}.slice.call arguments 0] : lambda [] : begin
		define CLOSED true
		local s : new SpiroExpansionContext1 (this.gizmo || GlobalTransform)
		local { .knots knots .closed closed } : prepareSpiroKnots [{}.slice.call args 0] s
		foreach knot [items-of knots] : let [ty knot.type] [af knot.af] : begin
			set knot.af : lambda [] : begin
				this.setType ty
				if af : af.apply this args

		SpiroJs.spiroToArcsOnContext knots closed s
		iterateNormals s closed
		iterateNormals s closed
		local {.lhs lhs .rhs rhs} : s.expand [fallback s.contrast Contrast]

		if closed : then
			this.includeGeometry : new CombineGeometry : list
				new SpiroGeometry [lhs.slice 0 (-1)]           closed [Transform.Id]
				new SpiroGeometry [rhs.reverse :.slice 0 (-1)] closed [Transform.Id]

		: else : begin
			lhs.0.type = lhs.(lhs.length - 1).type = 'corner'
			rhs.0.type = rhs.(rhs.length - 1).type = 'corner'
			define allKnots : lhs.concat : rhs.reverse
			this.includeGeometry : new SpiroGeometry allKnots CLOSED [Transform.Id]

		return { .knots knots .lhsKnots lhs .rhsKnots rhs }

	define [spiro-outline] : let [k : {}.slice.call arguments 0] : lambda [] : begin
		local gizmo : this.gizmo || GlobalTransform
		local g : new CurveUtil.BezToContoursSink gizmo
		local { .knots knots .closed closed } : prepareSpiroKnots k g
		this.includeGeometry : new SpiroGeometry knots closed gizmo

	return [object
		g4 g2 corner flat curl close end straight
		widths disable-contrast heading unimportant important
		alsoThru alsoThruThem bezcontrols quadcontrols archv arcvh complexThru
		dispiro spiro-outline]
